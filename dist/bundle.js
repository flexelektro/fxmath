var g=Object.defineProperty;var dt=Object.getOwnPropertyDescriptor;var Vt=Object.getOwnPropertyNames;var pt=Object.prototype.hasOwnProperty;var Mt=(i,t)=>{for(var r in t)g(i,r,{get:t[r],enumerable:!0})},ft=(i,t,r,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let e of Vt(t))!pt.call(i,e)&&e!==r&&g(i,e,{get:()=>t[e],enumerable:!(n=dt(t,e))||n.enumerable});return i};var wt=i=>ft(g({},"__esModule",{value:!0}),i);var zt={};Mt(zt,{PI:()=>P,PI2:()=>Y,RND:()=>b,V2:()=>y,V3:()=>p,_V2:()=>V,_v2:()=>w,atan:()=>H,atan2:()=>M,ceil:()=>v,clamp:()=>f,cos:()=>D,createPseudoPoissonDistribution:()=>it,debounce:()=>lt,dist:()=>A,exp:()=>$,floor:()=>W,fract:()=>U,isEven:()=>st,lerp:()=>a,log:()=>L,make2dArray:()=>at,make2dSquareArray:()=>ut,map:()=>E,mix:()=>X,modWrap:()=>B,pickRandom:()=>K,pickRandomFromArray:()=>Q,pow:()=>j,quinticinterpol:()=>rt,rand_box_muller:()=>R,random:()=>N,random2:()=>Z,randomWeightedFromArray:()=>nt,resetRNDHASH:()=>J,rnd:()=>x,rndInt:()=>O,round:()=>S,sawTooth:()=>mt,shuffleArray:()=>ht,sin:()=>k,smoothstep:()=>tt,sqrt:()=>_,swapVals:()=>et,tan:()=>F,v2:()=>d,v3:()=>l,weightedRandomLn:()=>I});module.exports=wt(zt);var{PI:P,log:L,sin:k,cos:D,tan:F,atan:H,atan2:M,random:N,floor:W,ceil:v,sqrt:_,round:S,exp:$,pow:j}=Math,Y=P*2;var E=(i,t,r,n,e)=>n+(i-t)/(r-t)*(e-n),a=(i,t,r)=>r*(t-i)+i,X=a,A=(i,t,r,n)=>Math.sqrt(Math.pow(i-r,2)+Math.pow(t-n,2)),x=(i,t,r=!1)=>{let n=r?Math.random():b();return i+(t-i)*n},O=(i,t)=>i+Math.floor(b()*(t-i+1)),Z=(i,t=12345)=>{let r=Math.sin(i*t)*1e4;return r-Math.floor(r)},C=i=>function(){var t=i+=1831565813;return t=Math.imul(t^t>>>15,t|1),t^=t+Math.imul(t^t>>>7,t|61),((t^t>>>14)>>>0)/4294967296};window?.$fx&&console.log("fxhash-api detected",window?.$fx.hash,window?.$fx.rand());var G=C(typeof window<"u"&&window?.$fx?$fx.rand()*1e4:Math.random()*1e4),J=i=>{G=C(i)},b=()=>G(),I=(i,t=!0)=>{let r=Math.exp(1),e=(Math.pow(r,2)-1)*i,m=Math.log(1+e)/2;return t?1-m:m},R=()=>{let i=0,t=0;for(;i===0;)i=b();for(;t===0;)t=b();let r=Math.sqrt(-2*Math.log(i))*Math.cos(2*Math.PI*t);return r=r/10+.5,r>1||r<0?R():r},K=(...i)=>{let t=i.length,r=Math.round(b()*(t-1));return i[r]},Q=(i,t=!1)=>{let r=i.length,n=window.fxrand?fxrand():Math.random(),e=Math.round(n*(r-1));return t?i.splice(e,1)[0]:i[e]},U=i=>i-Math.floor(i),f=(i,t=0,r=1)=>Math.min(r,Math.max(i,t)),B=(i,t=0,r=1)=>(i+(r-t))%(r-t)+t,tt=(i,t,r)=>{let n=f((r-i)/(t-i),0,1);return n*n*(3-2*n)},rt=(i,t,r)=>{let n=f((r-i)/(t-i),0,1);return n*n*n*(n*(n*6-15)+10)},it=i=>{let{W:t,H:r,size:n,perc:e,hasShiftRow:m}=i,s=[],u=Math.ceil(t/n),c=Math.ceil(r/n);for(let h=0;h<c;h++){let o=[];for(let z=0;z<u;z++){let ct=m&&h%2===0?n/2:0,bt=b(),ot=b(),T=bt*2*Math.PI,q=I(ot)*e/100*n,yt=q*Math.cos(T),xt=q*Math.sin(T);o.push(y.create(z*n+n/2+ct+yt,h*n+n/2+xt))}s.push(o)}return s},nt=i=>{let t=i.reduce((s,u)=>s+u.prob,0),r=0;i.forEach(s=>{s.start=r,s.end=r+s.prob,r=s.end});let e=(window.fxrand?fxrand():Math.random())*t;return i.find(s=>s.start<=e&&s.end>e).value},et=(i,t)=>{let r=t;return t=i,i=r,[]},st=i=>i%2===0;function mt(i,t){var n=(i+1e3*t)%(2*t);return n>t?2*t-n:n}function ut(i){let t=[];for(let r=0;r<i;r++){let n=[];for(let e=0;e<i;e++)n.push(0);t.push(n)}return t}function at(i,t){let r=[];for(let n=0;n<i;n++){let e=[];for(let m=0;m<t;m++)e.push(0);r.push(e)}return r}function ht(i){let t=i.length,r;for(;t!==0;)r=Math.floor(b()*t),t--,[i[t],i[r]]=[i[r],i[t]];return i}function lt(i,t){let r=null;return(...n)=>{r&&clearTimeout(r),r=setTimeout(()=>i(...n),t)}}var d=(i,t)=>new y(i,t),y=class i{constructor(t,r){this.x=t,this.y=r}static fromTo(t,r){return d(r.x-t.x,r.y-t.y)}static sameLike(t,r){return t.x===r.x&&t.y===r.y}static linesIntersect(t,r,n,e){let m=(e.y-n.y)*(r.x-t.x)-(e.x-n.x)*(r.y-t.y);if(m===0)return!1;let s=((e.x-n.x)*(t.y-n.y)-(e.y-n.y)*(t.x-n.x))/m,u=((r.x-t.x)*(t.y-n.y)-(r.y-t.y)*(t.x-n.x))/m;if(s<0||s>1||u<0||u>1)return!1;let c=t.x+s*(r.x-t.x),h=t.y+s*(r.y-t.y);return d(c,h)}static isPointInPolygon(t,r){let n=r.length,e=!1;for(let m=0,s=n-1;m<n;s=m++)r[m].y>t.y!=r[s].y>t.y&&t.x<(r[s].x-r[m].x)*(t.y-r[m].y)/(r[s].y-r[m].y)+r[m].x&&(e=!e);return e}static create(t,r){return new i(t,r)}static createByMagnitudeAndAngle(t,r){return new i(t*Math.cos(r),t*Math.sin(r))}static getAngle(t){return Math.atan2(t.y,t.x)}static angleBetween(t,r){return Math.acos(i.dotprod(t,r)/(t.magnitude*r.magnitude))}static clone(t){return new i(t.x,t.y)}static magnitude(t){return t.magnitude}static squareMagnitude(t){return t.squareMagnitude}static distance(t,r){return i.subtract(t,r).magnitude}static add(t,r){return new i(t.x+r.x,t.y+r.y)}static subtract(t,r){return new i(t.x-r.x,t.y-r.y)}static sub(t,r){return i.subtract(t,r)}static multiply(t,r){return new i(t.x*r,t.y*r)}static multVec(t,r){return new i(t.x*r.x,t.y*r.y)}static divide(t,r){return i.multiply(t,1/r)}static dotprod(t,r){return t.x*r.x+t.y*r.y}static dot(t,r){return i.dotprod(t,r)}static crossprod(t,r){return t.x*r.y-t.y*r.x}static unitVec(t){return i.divide(t,t.magnitude)}static projectionFromTo(t,r){let n=i.unitVec(r);return i.multiply(n,i.dotprod(t,n))}static rotate(t,r){let n=Math.cos(r),e=Math.sin(r);return new i(t.x*n-t.y*e,t.x*e+t.y*n)}static rotateAroundPivot(t,r,n){let e=Math.cos(n),m=Math.sin(n),s=t.x-r.x,u=t.y-r.y;return new i(e*s-m*u+r.x,m*s+e*u+r.y)}static normalLeft(t){return new i(-t.y,t.x)}static normalRight(t){return new i(t.y,-t.x)}static manhattanDistance(t,r){return Math.abs(t.x-r.x)+Math.abs(t.y-r.y)}static lerp(t,r,n){return new i(a(t.x,r.x,n),a(t.y,r.y,n))}clone(){return new i(this.x,this.y)}sameLike(t){return this.x===t.x&&this.y===t.y}copy(){return this.clone()}get angle(){return Math.atan2(this.y,this.x)}set angle(t){let r=this.magnitude;this.x=r*Math.cos(t),this.y=r*Math.sin(t)}setAngle(t){let r=this.magnitude;return this.x=r*Math.cos(t),this.y=r*Math.sin(t),this}get degree(){return 360/(2*Math.PI)*Math.atan2(this.y,this.x)}get toNormalRight(){let t=-this.y,r=this.x;return this.x=t,this.y=r,this}get toNormalLeft(){let t=this.y,r=-this.x;return this.x=t,this.y=r,this}set degree(t){let r=Math.PI*2/360*t;this.setAngle(r)}setDegree(t){let r=Math.PI*2/360*t;return this.setAngle(r)}get magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y)}get length(){return this.magnitude}get squareMagnitude(){return this.x*this.x+this.y*this.y}distance(t){return i.subtract(this,t).magnitude}unitVec(){return this.divide(this.magnitude)}add(t){return this.x+=t.x,this.y+=t.y,this}addRnd(t){return this.x+=x(-t,t),this.y+=x(-t,t),this}subtract(t){return this.x-=t.x,this.y-=t.y,this}sub(t){return this.subtract(t)}multiply(t){return this.x*=t,this.y*=t,this}multVec(t){return this.x*=t.x,this.y*=t.y,this}divide(t){return this.multiply(1/t)}dotprod(t){return this.x*t.x+this.y*t.y}dot(t){return this.dotprod(t)}crossprod(t){return this.x*t.y-this.y*t.x}rotate(t){return this.rotateAroundPivot(d(0,0),t)}rotateAroundPivot(t,r){let n=Math.cos(r),e=Math.sin(r),m=this.x-t.x,s=this.y-t.y,u=n*m-e*s+t.x,c=e*m+n*s+t.y;return this.x=u,this.y=c,this}toNormal(){let t=-this.y,r=this.x;return this.x=t,this.y=r,this}normal(){return new i(-this.y,this.x)}lerp(t,r){let n=i.lerp(this,t,r);return this.x=n.x,this.y=n.y,this}floorValues(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}isInPolygon(t){return i.isPointInPolygon(this,t)}};var w=(i,t)=>new V(i,t),V=class i{static fromTo(t,r){return w(r.x-t.x,r.y-t.y)}static sameLike(t,r){return t.x===r.x&&t.y===r.y}static linesIntersect(t,r,n,e){let m=(e.y-n.y)*(r.x-t.x)-(e.x-n.x)*(r.y-t.y);if(m===0)return!1;let s=((e.x-n.x)*(t.y-n.y)-(e.y-n.y)*(t.x-n.x))/m,u=((r.x-t.x)*(t.y-n.y)-(r.y-t.y)*(t.x-n.x))/m;if(s<0||s>1||u<0||u>1)return!1;let c=t.x+s*(r.x-t.x),h=t.y+s*(r.y-t.y);return w(c,h)}static isPointInPolygon(t,r){let n=r.length,e=!1;for(let m=0,s=n-1;m<n;s=m++)r[m].y>t.y!=r[s].y>t.y&&t.x<(r[s].x-r[m].x)*(t.y-r[m].y)/(r[s].y-r[m].y)+r[m].x&&(e=!e);return e}static create(t,r){return new i(t,r)}static createByMagnitudeAndAngle(t,r){return new i(t*Math.cos(r),t*Math.sin(r))}static getAngle(t){return Math.atan2(t.y,t.x)}static angleBetween(t,r){return Math.acos(i.dotprod(t,r)/(t.magnitude*r.magnitude))}static clone(t){return new i(t.x,t.y)}static magnitude(t){return t.magnitude}static squareMagnitude(t){return t.squareMagnitude}static distance(t,r){return i.subtract(t,r).magnitude}static add(t,r){return new i(t.x+r.x,t.y+r.y)}static subtract(t,r){return new i(t.x-r.x,t.y-r.y)}static sub(t,r){return i.subtract(t,r)}static multiply(t,r){return new i(t.x*r,t.y*r)}static multVec(t,r){return new i(t.x*r.x,t.y*r.y)}static divide(t,r){return i.multiply(t,1/r)}static dotprod(t,r){return t.x*r.x+t.y*r.y}static dot(t,r){return i.dotprod(t,r)}static crossprod(t,r){return t.x*r.y-t.y*r.x}static unitVec(t){return i.divide(t,t.magnitude)}static projectionFromTo(t,r){let n=i.unitVec(r);return i.multiply(n,i.dotprod(t,n))}static rotate(t,r){let n=Math.cos(r),e=Math.sin(r);return new i(t.x*n-t.y*e,t.x*e+t.y*n)}static rotateAroundPivot(t,r,n){let e=Math.cos(n),m=Math.sin(n),s=t.x-r.x,u=t.y-r.y;return new i(e*s-m*u+r.x,m*s+e*u+r.y)}static normalLeft(t){return new i(-t.y,t.x)}static normalRight(t){return new i(t.y,-t.x)}static manhattanDistance(t,r){return Math.abs(t.x-r.x)+Math.abs(t.y-r.y)}static lerp(t,r,n){return new i(a(t.x,r.x,n),a(t.y,r.y,n))}constructor(t,r){this.x=t,this.y=r}clone(){return new i(this.x,this.y)}add(t){return new i(this.x+t.x,this.y+t.y)}subtract(t){return new i(this.x-t.x,this.y-t.y)}multiply(t){return new i(this.x*t,this.y*t)}divide(t){return new i(this.x/t,this.y/t)}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}normalize(){let t=this.magnitude;return t===0?new i(0,0):this.divide(t)}rotate(t){let r=Math.cos(t),n=Math.sin(t);return new i(this.x*r-this.y*n,this.x*n+this.y*r)}normalLeft(){return new i(-this.y,this.x)}normalRight(){return new i(this.y,-this.x)}get magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y)}get squareMagnitude(){return this.x*this.x+this.y*this.y}distance(t){return this.subtract(t).magnitude}lerp(t,r){return new i(a(this.x,t.x,r),a(this.y,t.y,r))}floor(){return new i(Math.floor(this.x),Math.floor(this.y))}isInPolygon(t){return i.isPointInPolygon(this,t)}};var l=(i=0,t=0,r=0)=>new p(i,t,r),p=class i{constructor(t,r,n){this.x=t,this.y=r,this.z=n}static lerp(t,r,n){let e=a(t.x,r.x,n),m=a(t.y,r.y,n),s=a(t.z,r.z,n);return l(e,m,s)}static clone(t){return l(t.x,t.y,t.z)}static zero(){return l(0,0,0)}static up(){return l(0,1,0)}static add(t,r){let n=t.x+r.x,e=t.y+r.y,m=t.z+r.z;return l(n,e,m)}static sub(t,r){let n=t.x-r.x,e=t.y-r.y,m=t.z-r.z;return l(n,e,m)}static mult(t,r){let n=t.x*r,e=t.y*r,m=t.z*r;return l(n,e,m)}static multiply(t,r){return i.mult(t,r)}static divide(t,r){if(r===0)throw Error("Division by 0");let n=1/r;return i.mult(t,n)}static cross(t,r){let n=t.y*r.z-t.z*r.y,e=t.z*r.x-t.x*r.z,m=t.x*r.y-t.y*r.x;return new i(n,e,m)}static dot(t,r){return t.x*r.x+t.y*r.y+t.z*r.z}static abs(t){return l(Math.abs(t.x),Math.abs(t.y),Math.abs(t.z))}static max(t,r){let n=Math.max(t.x,r.x),e=Math.max(t.y,r.y),m=Math.max(t.z,r.z);return l(n,e,m)}zero(){return this.x=this.y=this.z=0,this}clone(){return l(this.x,this.y,this.z)}abs(){return this.x=Math.abs(this.x),this.y=Math.abs(this.y),this.z=Math.abs(this.z),this}add(t){return this.x=this.x+t.x,this.y=this.y+t.y,this.z=this.z+t.z,this}max(t){this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z)}sub(t){return this.x=this.x-t.x,this.y=this.y-t.y,this.z=this.z-t.z,this}mult(t){return this.x=this.x*t,this.y=this.y*t,this.z=this.z*t,this}multiply(t){return this.mult(t)}divide(t){let r=1/t;return this.x=this.x*r,this.y=this.y*r,this.z=this.z*r,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}dotProd(t){return this.dot(t)}cross(t){let r=this.x,n=this.y,e=this.z,m=t.x,s=t.y,u=t.z,c=n*u-e*s,h=e*m-r*u,o=r*s-n*m;return new i(c,h,o)}crossProd(t){return this.cross(t)}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}magnitude(){return this.length()}normalize(){return this.divide(this.length()||1)}unitVector(){return this.normalize()}static transformCoordinates(t,r){let{x:n,y:e,z:m}=t,s=r.m,u=n*s[0]+e*s[4]+m*s[8]+s[12],c=n*s[1]+e*s[5]+m*s[9]+s[13],h=n*s[2]+e*s[6]+m*s[10]+s[14],o=n*s[3]+e*s[7]+m*s[11]+s[15];return l(u/o,c/o,h)}static multiplyWithMatrix(t,r){let{x:n,y:e,z:m}=t,s=r.m,u=n*s[0]+e*s[4]+m*s[8]+s[12],c=n*s[1]+e*s[5]+m*s[9]+s[13],h=n*s[2]+e*s[6]+m*s[10]+s[14],o=n*s[3]+e*s[7]+m*s[11]+s[15];return l(u,c,h)}floorValues(){return this.x=this.x|0,this.y=this.y|0,this.z=this.z|0,this}angleXY(){return M(this.x,this.y)}toArray(){return[this.x,this.y,this.z]}};0&&(module.exports={PI,PI2,RND,V2,V3,_V2,_v2,atan,atan2,ceil,clamp,cos,createPseudoPoissonDistribution,debounce,dist,exp,floor,fract,isEven,lerp,log,make2dArray,make2dSquareArray,map,mix,modWrap,pickRandom,pickRandomFromArray,pow,quinticinterpol,rand_box_muller,random,random2,randomWeightedFromArray,resetRNDHASH,rnd,rndInt,round,sawTooth,shuffleArray,sin,smoothstep,sqrt,swapVals,tan,v2,v3,weightedRandomLn});
//# sourceMappingURL=bundle.js.map
