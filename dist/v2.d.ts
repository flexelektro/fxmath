declare const v2: (x: number, y: number) => V2;
declare class V2 {
    x: number;
    y: number;
    constructor(x: number, y: number);
    static fromTo(a: V2, b: V2): V2;
    static sameLike(a: V2, b: V2): boolean;
    static linesIntersect(pA: V2, pA2: V2, pB: V2, pB2: V2): false | V2;
    static isPointInPolygon(p: V2, poly: V2[]): boolean;
    static create(x: number, y: number): V2;
    static createByMagnitudeAndAngle(mag: number, angle: number): V2;
    static getAngle(v: V2): number;
    static angleBetween(a: V2, b: V2): number;
    static clone(v: V2): V2;
    static magnitude(v: V2): number;
    static length_(v: V2): number;
    static squareMagnitude(v: V2): number;
    static distance(v1: V2, v2: V2): number;
    static add(v1: V2, v2: V2): V2;
    static subtract(v1: V2, v2: V2): V2;
    static multiply(vector: V2, scalar: number): V2;
    static multVec(v0: V2, v1: V2): V2;
    static divide(v: V2, scalar: number): V2;
    static dotprod(v1: V2, v2: V2): number;
    static dot(v1: V2, v2: V2): number;
    static crossprod(v1: V2, v2: V2): number;
    static unitVec(v: V2): V2;
    static projectionFromTo(v1: V2, v2: V2): V2;
    static rotate(v: V2, angle: number): V2;
    static rotateAroundPivot(point: V2, pivot: V2, angleRad: number): V2;
    static normal(v: V2): V2;
    static normalLeft(v: V2): V2;
    static normalRight(v: V2): V2;
    static manhattanDistance(v1: V2, v2: V2): number;
    static lerp(v1: V2, v2: V2, amt: number): V2;
    clone(): V2;
    sameLike(v: V2): boolean;
    copy(): V2;
    get angle(): number;
    set angle(rad: number);
    setAngle(rad: number): this;
    get degree(): number;
    get normalRight(): this;
    get normalLeft(): this;
    set degree(degree: number);
    setDegree(degree: number): this;
    get magnitude(): number;
    get length(): number;
    get squareMagnitude(): number;
    distance(v: V2): number;
    unitVec(): V2;
    add(v: V2): this;
    addRnd(rand: number): this;
    subtract(v: V2): this;
    multiply(scalar: number): this;
    multVec(v: V2): this;
    divide(scalar: number): this;
    dotprod(v: V2): number;
    dot(v: V2): number;
    crossprod(v: V2): number;
    rotate(angle: number): this;
    rotateAroundPivot(pivot: V2, angleRad: number): this;
    normal(): this;
    lerp(v: V2, amt: number): this;
    floorValues(): this;
    isInPolygon(poly: V2[]): boolean;
}
export { v2, V2 };
